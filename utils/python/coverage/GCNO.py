#!/usr/bin/env python3.4
#
# Copyright (C) 2016 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""Parses the contents of a GCNO file generated by the GCC compiler.

The parse() function returns a GCNOSummary object, which
contains descriptions of all functions in the parsed .gcno file. Each
FunctionSummary object describes the code blocks within each function,
the line numbers associated within each block, and the arcs exiting/entering
each block.


    Typical usage example:

    summary = parse(fileName)
"""

import logging
import struct
import sys
import math
from vts.utils.python.coverage import ArcSummary
from vts.utils.python.coverage import BlockSummary
from vts.utils.python.coverage import FunctionSummary
from vts.utils.python.coverage import GCNOSummary


class FileFormatError(Exception):
    """Exception for invalid GCNO file format.

    Thrown when an unexpected value type is read from the file stream
    or when the end of file is reached unexpectedly."""

    pass


class Parser(object):
    """Parser object class stores stateful information for parsing GCNO file.

    Stores the file stream and summary object as it is updated.

    Attributes:
        stream: File stream object for a GCNO file
        format: Character denoting the endianness of the file
        summary: The GCNOSummary object describing the GCNO file
        version: The (integer) version of the GCNO file
    """

    NOTE_MAGIC = 0x67636e6f
    TAG_FUNCTION = 0x01000000
    TAG_BLOCKS = 0x01410000
    TAG_ARCS = 0x01430000
    TAG_LINES = 0x01450000
    BYTES_IN_WORD = 4
    HEADER_LENGTH = 3  #  number of words in a section header

    def __init__(self, stream):
        """Inits the parser with the input stream and default values.

        The byte order is set by default to little endian and the summary file
        is instantiated with an empty GCNOSummary object.

        Args:
            stream: An input binary file stream to a .gcno file
        """
        self.stream = stream
        self.format = '<'
        self.summary = GCNOSummary.GCNOSummary()

        magic = self.ReadInt()
        self.version = ''.join(
            struct.unpack(self.format + 'ssss', self.stream.read(4)))
        self.ReadInt()  #   stamp

        if magic != self.NOTE_MAGIC:
            magic = struct.unpack('>I', struct.pack('<I', magic))[0]
            if magic == self.NOTE_MAGIC:  #  switch endianness
                self.format = '>'
            else:
                raise FileFormatError('Invalid file format.')

    def parse(self):
        """Runs the parser on the file opened in the stream attribute.

        Reads the binary file and extracts functions, blocks, arcs, and
        lines. Information is stored the summary attribute.

        Returns:
            GCNOSummary object representing the functions, blocks, arcs,
            and lines in the opened GCNO file.

        Raises:
            FileFormatError: invalid file format.
        """

        func = None

        while True:
            tag = str()

            try:
                while True:
                    tag = self.ReadInt()
                    if (tag == self.TAG_FUNCTION or tag == self.TAG_BLOCKS or
                            tag == self.TAG_ARCS or tag == self.TAG_LINES):
                        break
                length = self.ReadInt()
            except FileFormatError:
                self.summary.functions.append(func)
                return self.summary  #  end of file reached

            if tag == self.TAG_FUNCTION:
                if func:
                    self.summary.functions.append(func)
                func = self.ReadFunction()

            elif tag == self.TAG_BLOCKS:
                self.ReadBlocks(length, func)

            elif tag == self.TAG_ARCS:
                self.ReadArcs(length, func)

            elif tag == self.TAG_LINES:
                self.ReadLines(length, func)

    def ReadInt(self):
        """Reads and returns an integer from the stream.

        Returns:
          A 4-byte integer from the stream attribute.

        Raises:
          TypeError: The 4-byte sequence is not an integer.
          ValueError: I/O operation on closed file.
          FileFormatError: End of file reached.
        """
        try:
            return struct.unpack(self.format + 'I', self.stream.read(4))[0]
        except (TypeError, ValueError, struct.error):
            raise FileFormatError('Corrupt file.')

    def ReadString(self):
        """Reads and returns a string from the stream.

        First reads an integer denoting the number of words to read,
        then reads and returns the string with trailing padding characters
        stripped.

        Returns:
            A string from the stream attribute.

        Raises:
            FileFormatError: End of file reached.
        """
        length = self.ReadInt() << 2
        if length > 0:
            try:
                return ''.join(
                    struct.unpack(self.format + 's' * length, self.stream.read(
                        length))).rstrip('\x00')
            except (TypeError, ValueError, struct.error):
                raise FileFormatError('Corrupt file.')
        return str()

    def ReadFunction(self):
        """Reads and returns a function from the stream.

        Reads information about a function from the gcno file stream and
        returns a summary object.

        Returns:
            FunctionSummary object containing the function name, source file,
            and first line number.

        Raises:
            FileFormatError: Function could not be read.
        """
        ident = self.ReadInt()
        self.ReadInt()  #  line number checksum
        if int(self.version[1]) > 4:
            self.ReadInt()  #  configuration checksum
        name = self.ReadString()
        source_file_name = self.ReadString()
        first_line_number = self.ReadInt()
        return FunctionSummary.FunctionSummary(ident, name, source_file_name,
                               first_line_number)

    def ReadBlocks(self, length, func):
        """Reads the basic block information from the stream.

        Reads information about the basic blocks from the gcno file
        stream and updates the specified function.

        Args:
            length: number of blocks to read
            func: FunctionSummary object for the blocks' parent function

        Raises:
            FileFormatError: Blocks could not be read. Corrupt file.
        """

        blocks = []
        for _ in range(length):
            block_flag = self.ReadInt()
            block = BlockSummary.BlockSummary(len(blocks), block_flag)
            blocks.append(block)
        func.blocks.extend(blocks)

    def ReadArcs(self, length, func):
        """Reads the arcs from the stream.

        Parses the arcs from the gcno file and updates the input
        function summary with arc information.

        Args:
            length: represents the number of bytes to read
            func: FunctionSummary object for the arcs' parent fuction

        Raises:
            FileFormatError: Arcs could not be read. Corrupt file.
        """

        src_block_index = self.ReadInt()
        n_arcs = (length - 1) / 2
        arcs = []
        for _ in range(n_arcs):
            dst_block_index = self.ReadInt()
            flag = self.ReadInt()
            arc = ArcSummary.ArcSummary(src_block_index, dst_block_index, flag)
            arcs.append(arc)

        src_block = func.blocks[src_block_index]
        for arc in arcs:
            src_block.exit_arcs.append(arc)
            dst_block = func.blocks[arc.dst_block_index]
            dst_block.entry_arcs.append(arc)

    def ReadLines(self, length, func):
        """Reads the line information from the stream.

        Parses the lines from the gcno file and updates the input
        function summary with line information.

        Args:
            length: represents the number of bytes to read
            func: FunctionSummary object for the lines' parent fuction

        Raises:
            FileFormatError: Lines could not be read. Corrupt file.
        """

        block_number = self.ReadInt()
        self.ReadInt()  #  dummy value
        lines = []
        src = self.ReadString()  #  source file name
        src_length = int(math.ceil(len(src)*1.0/self.BYTES_IN_WORD)) + 1
        for i in range(length - src_length - self.HEADER_LENGTH):
            line = self.ReadInt()
            if line:
                lines.append(line)
        func.blocks[block_number].lines = lines


def parse(file_name):
    """Parses the .gcno file specified by the input.

    Reads the .gcno file specified and parses the information describing
    basic blocks, functions, and arcs.

    Args:
        file_name: A string file path to a .gcno file

    Returns:
        A GCNOSummary object containing information about all of the
        fuctions, blocks, and arcs in the .gcno file.
    """

    with open(file_name, 'rb') as stream:
        return Parser(stream).parse()


def GenerateCoverageReport(src_file_content, gcov_file_content, basicblock_id_list):
    """Returns the produced html file contents."""
    logging.info("GenerateCoverageReport: src_file_content %s",
                 src_file_content)
    logging.info("GenerateCoverageReport: gcov_file_content %s",
                 gcov_file_content)
    logging.info("GenerateCoverageReport: basicblock_id_list %s",
                 basicblock_id_list)
    return "<table border=0><tr><td>Code coverage will show up at here</table>"


if __name__ == '__main__':
    if len(sys.argv) < 3 or sys.argv[1] != '-f':
        print('usage: gcno.py -f [file name]')
    else:
        print(parse(sys.argv[2]).ToString())
